// <auto-generated />
using System.Collections;
using System.Collections.Generic;
using System.IO;
using System.Text;
using DefensiveProgrammingFramework;
using TorrentFlow.TorrentClientLibrary.Exceptions;
using TorrentFlow.TorrentClientLibrary.Extensions;

namespace TorrentFlow.TorrentClientLibrary.BEncoding
{
    public class BEncodedDictionary : BEncodedValue, IDictionary<BEncodedString, BEncodedValue>
    {
        private SortedDictionary<BEncodedString, BEncodedValue> dictionary;
        public BEncodedDictionary()
        {
            this.dictionary = new SortedDictionary<BEncodedString, BEncodedValue>();
        }
        public int Count
        {
            get
            {
                return this.dictionary.Count;
            }
        }
        public bool IsReadOnly
        {
            get
            {
                return false;
            }
        }
        public ICollection<BEncodedString> Keys
        {
            get
            {
                return this.dictionary.Keys;
            }
        }
        public ICollection<BEncodedValue> Values
        {
            get
            {
                return this.dictionary.Values;
            }
        }
        public BEncodedValue this[BEncodedString key]
        {
            get
            {
                key.CannotBeNull();

                return this.dictionary[key];
            }

            set
            {
                this.dictionary[key] = value;
            }
        }
        public static BEncodedDictionary DecodeTorrent(byte[] bytes)
        {
            bytes.CannotBeNullOrEmpty();

            return DecodeTorrent(new MemoryStream(bytes));
        }
        public static BEncodedDictionary DecodeTorrent(Stream stream)
        {
            stream.CannotBeNull();

            return DecodeTorrent(new RawReader(stream));
        }
        public static BEncodedDictionary DecodeTorrent(RawReader reader)
        {
            reader.CannotBeNull();

            BEncodedString key = null;
            BEncodedValue value = null;
            BEncodedDictionary torrent = new BEncodedDictionary();

            if (reader.ReadByte() != 'd')
            {
                throw new BEncodingException("Invalid data found. Aborting"); // Remove the leading 'd'
            }

            while (reader.PeekByte() != -1 &&
                   reader.PeekByte() != 'e')
            {
                key = (BEncodedString)BEncodedValue.Decode(reader);         // keys have to be BEncoded strings

                if (reader.PeekByte() == 'd')
                {
                    value = new BEncodedDictionary();

                    if (key.Text.ToLower().Equals("info"))
                    {
                        ((BEncodedDictionary)value).DecodeInternal(reader, true);
                    }
                    else
                    {
                        ((BEncodedDictionary)value).DecodeInternal(reader, false);
                    }
                }
                else
                {
                    value = BEncodedValue.Decode(reader);                     // the value is a BEncoded value
                }

                torrent.dictionary.Add(key, value);
            }

            if (reader.ReadByte() != 'e')
            {
                throw new BEncodingException("Invalid data found. Aborting");
            }

            return torrent;
        }
        public void Add(BEncodedString key, BEncodedValue value)
        {
            key.CannotBeNull();
            value.CannotBeNull();

            this.dictionary.Add(key, value);
        }
        public void Add(KeyValuePair<BEncodedString, BEncodedValue> item)
        {
            this.dictionary.Add(item.Key, item.Value);
        }
        public void Clear()
        {
            this.dictionary.Clear();
        }
        public bool Contains(KeyValuePair<BEncodedString, BEncodedValue> item)
        {
            if (!this.dictionary.ContainsKey(item.Key))
            {
                return false;
            }
            else
            {
                return this.dictionary[item.Key].Equals(item.Value);
            }
        }
        public bool ContainsKey(BEncodedString key)
        {
            key.CannotBeNull();

            return this.dictionary.ContainsKey(key);
        }
        public void CopyTo(KeyValuePair<BEncodedString, BEncodedValue>[] array, int arrayIndex)
        {
            array.CannotBeNullOrEmpty();
            arrayIndex.MustBeGreaterThanOrEqualTo(0);

            this.dictionary.CopyTo(array, arrayIndex);
        }
        public override int Encode(byte[] buffer, int offset)
        {
            buffer.CannotBeNullOrEmpty();
            offset.MustBeGreaterThanOrEqualTo(0);

            int written = 0;

            buffer[offset] = (byte)'d'; // dictionaries start with 'd'
            written++;

            foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in this)
            {
                written += keypair.Key.Encode(buffer, offset + written);
                written += keypair.Value.Encode(buffer, offset + written);
            }

            buffer[offset + written] = (byte)'e'; // dictionaries end with 'e'

            written++;

            return written;
        }
        public override bool Equals(object obj)
        {
            BEncodedValue val;
            BEncodedDictionary other = obj as BEncodedDictionary;

            if (other == null)
            {
                return false;
            }

            if (this.dictionary.Count != other.dictionary.Count)
            {
                return false;
            }

            foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in this.dictionary)
            {
                if (!other.TryGetValue(keypair.Key, out val))
                {
                    return false;
                }

                if (!keypair.Value.Equals(val))
                {
                    return false;
                }
            }

            return true;
        }
        public IEnumerator<KeyValuePair<BEncodedString, BEncodedValue>> GetEnumerator()
        {
            return this.dictionary.GetEnumerator();
        }
        IEnumerator IEnumerable.GetEnumerator()
        {
            return this.dictionary.GetEnumerator();
        }
        public override int GetHashCode()
        {
            int result = 0;

            foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in this.dictionary)
            {
                result ^= keypair.Key.GetHashCode();
                result ^= keypair.Value.GetHashCode();
            }

            return result;
        }
        public override int LengthInBytes()
        {
            int length = 0;

            length += 1;   // Dictionaries start with 'd'

            foreach (KeyValuePair<BEncodedString, BEncodedValue> keypair in this.dictionary)
            {
                length += keypair.Key.LengthInBytes();
                length += keypair.Value.LengthInBytes();
            }

            length += 1;   // Dictionaries end with 'e'

            return length;
        }
        public bool Remove(BEncodedString key)
        {
            key.CannotBeNull();

            return this.dictionary.Remove(key);
        }
        public bool Remove(KeyValuePair<BEncodedString, BEncodedValue> item)
        {
            return this.dictionary.Remove(item.Key);
        }
        public override string ToString()
        {
            return Encoding.UTF8.GetString(this.Encode());
        }
        public bool TryGetValue(BEncodedString key, out BEncodedValue value)
        {
            key.CannotBeNull();

            return this.dictionary.TryGetValue(key, out value);
        }
        internal override void DecodeInternal(RawReader reader)
        {
            reader.CannotBeNull();

            this.DecodeInternal(reader, reader.StrictDecoding);
        }
        private void DecodeInternal(RawReader reader, bool strictDecoding)
        {
            reader.CannotBeNull();

            BEncodedString key = null;
            BEncodedValue value = null;
            BEncodedString oldkey = null;

            if (reader.ReadByte() != 'd')
            {
                throw new BEncodingException("Invalid data found. Aborting"); // Remove the leading 'd'
            }

            while (reader.PeekByte() != -1 &&
                   reader.PeekByte() != 'e')
            {
                key = (BEncodedString)BEncodedValue.Decode(reader);         // keys have to be BEncoded strings

                if (oldkey != null &&
                    oldkey.CompareTo(key) > 0)
                {
                    if (strictDecoding)
                    {
                        throw new BEncodingException($"Illegal BEncodedDictionary. The attributes are not ordered correctly. Old key: {oldkey}, New key: {key}");
                    }
                }

                oldkey = key;
                value = BEncodedValue.Decode(reader);                     // the value is a BEncoded value
                this.dictionary.Add(key, value);
            }

            if (reader.ReadByte() != 'e')
            {
                throw new BEncodingException("Invalid data found. Aborting");
            }
        }
    }
}
